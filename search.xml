<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo</title>
    <url>/2019/06/10/Hello-Hexo/</url>
    <content><![CDATA[<h1 id="Hello-Hexo"><a href="#Hello-Hexo" class="headerlink" title="Hello Hexo"></a>Hello Hexo</h1><hr>
<p>It does take me sometime to build up my own blog site.</p>
<p><strong>TODO</strong></p>
<ol>
<li>Going to bed, it is 1:20 AM.</li>
<li>Writing a post on how to build this.</li>
<li>Writing a post about my Newifi-D2 with OpenWrt installed.</li>
</ol>
]]></content>
      <tags>
        <tag>Start</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn My Old Code</title>
    <url>/2020/04/30/Learn-my-old-code/</url>
    <content><![CDATA[<p>Read the code I read serveral months ago.</p>
<span id="more"></span>

<h1 id="Learn-My-Old-Code"><a href="#Learn-My-Old-Code" class="headerlink" title="Learn My Old Code"></a>Learn My Old Code</h1><p>Code are all in my old repo <code>DoKernel</code> </p>
<p>This post is a review for improving my next repo dotkernel. there are 2 reusable files.</p>
<h2 id="config-x2F-config-mk"><a href="#config-x2F-config-mk" class="headerlink" title="config&#x2F;config.mk"></a>config&#x2F;config.mk</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">DIR_PATH=/home/doot/sysmaking/dokernel</span><br><span class="line"></span><br><span class="line">TOOLS_PREFIX = /usr/local/cross/bin/i686-elf-</span><br><span class="line"></span><br><span class="line">CC = $&#123;TOOLS_PREFIX&#125;gcc</span><br><span class="line">CXX = $&#123;TOOLS_PREFIX&#125;g++</span><br><span class="line">LD = $&#123;TOOLS_PREIFX&#125;ld</span><br><span class="line">AS = nasm </span><br><span class="line">OBJCOPY = $&#123;TOOLS_PREIFX&#125;objcopy</span><br><span class="line"></span><br><span class="line">BIN = img.bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AS_FLAGS = -f elf32 -F dwarf -g</span><br><span class="line">LINK_FLAGS = -ffreestanding -nostdlib -g</span><br><span class="line">CC_FLAGS = -std=gnu11 -ffreestanding -m32 -masm=intel -Wall -Wextra -Wno-address-of-packed-member -g -O0</span><br><span class="line"></span><br><span class="line">OBJCOPY_GENBIN_FLAGS = -O binary -S</span><br><span class="line">OBJCOPY_GENSYM_FLAGS = --only-keep-debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CLEAN_CMD = find . | grep -e  <span class="string">&quot;\.o&quot;</span> -e <span class="string">&quot;\.elf&quot;</span> -e <span class="string">&quot;\.bin&quot;</span> -e <span class="string">&quot;\.debug&quot;</span> | xargs rm </span><br></pre></td></tr></table></figure>


<ol>
<li>assembler flags : <code>-f elf32</code> for output format, <code>-F dwarf</code> for debug infomation format, <code>-g</code> for enable debug infomation</li>
<li>linker flags : <code>-ffreestanding</code> means that standard library may not exst or enable the freestanding environment, <code>-nostdlib</code> tells linker not to link startup files.</li>
<li>compiler flags : <code>-std=gun11</code>, <code>-ffreestanding</code>, <code>-m32</code> means generating code for 32bit abi, <code>-masm=intel</code> choices the intel syntax, <code>-Wall</code>, <code>-Wextra</code>, <code>-Wno-address-of-packed-member</code> disable some warning.</li>
</ol>
<h2 id="boot-x2F-link-ld"><a href="#boot-x2F-link-ld" class="headerlink" title="boot&#x2F;link.ld"></a>boot&#x2F;link.ld</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* jump to here to run */</span></span><br><span class="line">    . = <span class="number">0x7C00</span>;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        boot.o(.text)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .data :</span><br><span class="line">    &#123;</span><br><span class="line">        boot.o(.data)</span><br><span class="line">        boot.o(.rodata)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allsize = ABSOLUTE(.);</span><br><span class="line">    .mbrcheck : </span><br><span class="line">    &#123;</span><br><span class="line">        . = <span class="number">0x7C00</span> + <span class="number">512</span> - allsize - <span class="number">2</span>;</span><br><span class="line">        boot.o(.mbrcheck)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    . = <span class="number">0x9000</span>;</span><br><span class="line">    .text<span class="number">.1</span> : AT(<span class="number">0x7c00</span> + <span class="number">0x200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        boot.o(.text<span class="number">.1</span>)</span><br><span class="line">        . = ALIGN(<span class="number">0x200</span>) - <span class="number">1</span>;</span><br><span class="line">        BYTE(<span class="number">0xcc</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It seems that there are no hightlighting scheme for link script, I just use <code>C</code>.</p>
<ol>
<li><code>. = 0x7c00</code>, assign the VMA and MBR is here to run.</li>
<li><code> allsize = ABSOLUTE(.)</code>, we can get the size of code and data above.</li>
<li><code> AT(0x7c00 + 0x200)</code>, assign the LMA of the section</li>
</ol>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim + clangd Configuration</title>
    <url>/2019/09/28/Neovim-clangd/</url>
    <content><![CDATA[<p><img src="/img/nvimandclangd.png" alt="avator"><br>For Productivity!!!</p>
<span id="more"></span>

<p>And ZhuangBility23333</p>
<h2 id="Neovim-clangd-Configuration"><a href="#Neovim-clangd-Configuration" class="headerlink" title="Neovim + clangd Configuration"></a>Neovim + clangd Configuration</h2><h3 id="1-Neovim"><a href="#1-Neovim" class="headerlink" title="1. Neovim"></a>1. <a href="https://github.com/neovim/neovim">Neovim</a></h3><p>I am using Ubuntu18.04 and version of neovim installed by apt is not latest. I choose the installation from source.</p>
<h4 id="How-to-install"><a href="#How-to-install" class="headerlink" title="How to install"></a>How to install</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/neovim/neovim.git</span><br><span class="line"><span class="built_in">cd</span> neovim</span><br><span class="line">git checkout v0.4.2</span><br><span class="line">make CMAKE_BUILD_TYPE=RelWithDebInfo</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h4 id="How-to-uninstall"><a href="#How-to-uninstall" class="headerlink" title="How to uninstall"></a>How to uninstall</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /usr/local/bin/nvim</span><br><span class="line">sudo <span class="built_in">rm</span> -r /usr/local/share/nvim/</span><br></pre></td></tr></table></figure>

<h3 id="2-Vim-plug"><a href="#2-Vim-plug" class="headerlink" title="2. Vim-plug"></a>2. <a href="https://github.com/junegunn/vim-plug">Vim-plug</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>

<h3 id="3-LanguageClient-neovim"><a href="#3-LanguageClient-neovim" class="headerlink" title="3. LanguageClient-neovim"></a>3. <a href="https://github.com/autozimu/LanguageClient-neovim">LanguageClient-neovim</a></h3><p>Create file at <code>~/.config/nvim/init.vim</code> ,filling it with following content.</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.config/nvim/plugged&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Plug <span class="string">&#x27;autozimu/LanguageClient-neovim&#x27;</span>, &#123;</span><br><span class="line">    \ <span class="string">&#x27;branch&#x27;</span>: <span class="string">&#x27;next&#x27;</span>,</span><br><span class="line">    \ <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;bash install.sh&#x27;</span>,</span><br><span class="line">    \ &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; (Optional) Multi-entry selection UI.</span></span><br><span class="line">Plug <span class="string">&#x27;junegunn/fzf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Enter nvim and just type <code>:PlugInstall</code> + <code>Enter</code> to install LanguageClient-neovim, just wait.</p>
<h3 id="4-deoplete-nvim"><a href="#4-deoplete-nvim" class="headerlink" title="4. deoplete.nvim"></a>4. <a href="https://github.com/Shougo/deoplete.nvim">deoplete.nvim</a></h3><p>Add following content to <code>init.vim</code>, between <code>call plug#begin</code> and <code>call plug#end</code>.</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">  Plug <span class="string">&#x27;Shougo/deoplete.nvim&#x27;</span>, &#123; <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;:UpdateRemotePlugins&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  Plug <span class="string">&#x27;Shougo/deoplete.nvim&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/nvim-yarp&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/vim-hug-neovim-rpc&#x27;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:deoplete</span>#enable_at_startup = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>After it, the file looks like this:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.config/nvim/plugged&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Plug <span class="string">&#x27;autozimu/LanguageClient-neovim&#x27;</span>, &#123;</span><br><span class="line">    \ <span class="string">&#x27;branch&#x27;</span>: <span class="string">&#x27;next&#x27;</span>,</span><br><span class="line">    \ <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;bash install.sh&#x27;</span>,</span><br><span class="line">    \ &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; (Optional) Multi-entry selection UI.</span></span><br><span class="line">Plug <span class="string">&#x27;junegunn/fzf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">  Plug <span class="string">&#x27;Shougo/deoplete.nvim&#x27;</span>, &#123; <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;:UpdateRemotePlugins&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  Plug <span class="string">&#x27;Shougo/deoplete.nvim&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/nvim-yarp&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/vim-hug-neovim-rpc&#x27;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:deoplete</span>#enable_at_startup = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-Clang-and-LLVM"><a href="#5-Clang-and-LLVM" class="headerlink" title="5. Clang and LLVM"></a>5. <a href="https://clang.llvm.org/">Clang and LLVM</a></h3><p>how to add clang’s apt repo : <a href="https://apt.llvm.org/">https://apt.llvm.org/</a></p>
<p>As for Ununtu18.04, I do the following things :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GPG Key</span></span><br><span class="line">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># Repo source</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">&quot;deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-9 main&quot;</span> &gt;&gt; /etc/apt/source.list</span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">&quot;deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-9 main&quot;</span> &gt;&gt; /etc/apt/source.list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install clang-9</span><br><span class="line">sudo apt install clangd-9</span><br><span class="line"></span><br><span class="line"><span class="comment"># For GNU/Linux libstd++</span></span><br><span class="line"><span class="comment"># For OSX libc++</span></span><br><span class="line">sudo apt install libstdc++-8-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">## Uninstall default clang and clangd before next step</span></span><br><span class="line"></span><br><span class="line">sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-9 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-9 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-9 100</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-Edit-the-init-vim"><a href="#6-Edit-the-init-vim" class="headerlink" title="6. Edit the init.vim"></a>6. Edit the init.vim</h3><p>add following content after <code>plug#end()</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&quot;make sign column always visiable</span></span><br><span class="line"><span class="keyword">set</span> signcolumn=yes</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;make indent 4 spaces</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;enable neovim-LanguageClient</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:LanguageClient_autoStart</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;set clangd as server when it is C++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:LanguageClient_serverCommands</span> = &#123;</span><br><span class="line">    \ <span class="string">&#x27;cpp&#x27;</span>: [<span class="string">&#x27;clangd&#x27;</span>],</span><br><span class="line">    \ &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;set complete function for deoplete.vim</span></span><br><span class="line"><span class="keyword">set</span> completefunc=LanguageClient#complete</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-Enjoy"><a href="#7-Enjoy" class="headerlink" title="7. Enjoy"></a>7. Enjoy</h3><p>open <code>nvim</code> and Enjoy~~~</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>Don’t forget to generate compile_commands.json.</p>
<p>Reference : <a href="https://clang.llvm.org/extra/clangd/Installation.html#project-setup">GETTING STARTED WITH CLANGD</a></p>
]]></content>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
        <tag>productivity</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes About Linker Script</title>
    <url>/2020/04/30/Notes-about-linker-script/</url>
    <content><![CDATA[<p>Some notes about how to write linker script.</p>
<span id="more"></span>

<h2 id="Linker-Script"><a href="#Linker-Script" class="headerlink" title="Linker Script"></a>Linker Script</h2><p>Linker script is used to instruct the linker to generate the final objective file.</p>
<p>here is an example:</p>
<blockquote>
<p>see <a href="https://github.com/D0ot/learnlinkerscript">this</a> for whole example.</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS </span><br><span class="line">&#123;</span><br><span class="line">    . = <span class="number">0x50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* same as .data : AT(0x100) */</span></span><br><span class="line">    <span class="comment">/* LMA is same as VMA by default*/</span></span><br><span class="line">    .data :</span><br><span class="line">    &#123;</span><br><span class="line">        *.o(.data)</span><br><span class="line">        BYTE(<span class="number">0xcc</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v1 = .;</span><br><span class="line">    <span class="comment">/* LMA is different from VMA */</span></span><br><span class="line">    .sec2 : AT(<span class="number">0x70</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LONG(.)</span><br><span class="line">        BYTE(<span class="number">0xcf</span>)</span><br><span class="line">        LONG(.)</span><br><span class="line">        LONG(ABSOLUTE(.))</span><br><span class="line">        LONG(v1)</span><br><span class="line">        BYTE(<span class="number">0xcf</span>)</span><br><span class="line">        *.o(.sec2)</span><br><span class="line">        BYTE(<span class="number">0xcc</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v2 = .;</span><br><span class="line">    .text : AT(<span class="number">0x90</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        BYTE(<span class="number">0xcc</span>) </span><br><span class="line">        sample.o(.text)</span><br><span class="line">        BYTE(<span class="number">0xcc</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .text : AT(<span class="number">0x110</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sample2.o(.text)</span><br><span class="line">        BYTE(<span class="number">0xcc</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .rodata :</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(<span class="number">16</span>);</span><br><span class="line">        BYTE(<span class="number">0xcf</span>)</span><br><span class="line">        . = . + <span class="number">50</span>;</span><br><span class="line">        BYTE(<span class="number">0xcf</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>VMA : virtual memory address<br>LMA : load memroy address</p>
<p><code>. = xxx</code> sets VMA<br><code>AT(xxx)</code> sets LMA</p>
<p>Done.</p>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title>Oh My Zsh</title>
    <url>/2019/06/24/Oh-My-Zsh/</url>
    <content><![CDATA[<blockquote>
<p>“Oh My Zsh will not make you a 10x developer…but you might feel like one.”</p>
</blockquote>
<span id="more"></span>

<h2 id="What-is-“Oh-My-Zsh”"><a href="#What-is-“Oh-My-Zsh”" class="headerlink" title="What is “Oh My Zsh”"></a>What is “Oh My Zsh”</h2><p>This is what i copied from the project’s github[1]</p>
<blockquote>
<p>A delightful community-driven (with 1,300+ contributors) framework for managing your zsh configuration. Includes 200+ optional plugins (rails, git, OSX, hub, capistrano, brew, ant, php, python, etc), over 140 themes to spice up your morning, and an auto-update tool so that makes it easy to keep up with the latest updates from the community. <a href="https://ohmyz.sh/">https://ohmyz.sh/</a></p>
</blockquote>
<hr>
<h2 id="My-configuration-steps"><a href="#My-configuration-steps" class="headerlink" title="My configuration steps"></a>My configuration steps</h2><p>The following commands shown are from these projects’ README.md.</p>
<p>References are listed below.</p>
<h3 id="1-Install-Oh-My-Zsh"><a href="#1-Install-Oh-My-Zsh" class="headerlink" title="#1 Install Oh-My-Zsh"></a>#1 Install Oh-My-Zsh</h3><p>I prefered using Wget, so</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-Install-zsh-completion-2"><a href="#2-Install-zsh-completion-2" class="headerlink" title="#2 Install zsh-completion [2]"></a>#2 Install zsh-completion [2]</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-completions $&#123;ZSH_CUSTOM:=~/.oh-my-zsh/custom&#125;/plugins/zsh-completions</span><br></pre></td></tr></table></figure>

<h3 id="3-Install-zsh-syntax-highlight-3"><a href="#3-Install-zsh-syntax-highlight-3" class="headerlink" title="#3 Install zsh-syntax-highlight [3]"></a>#3 Install zsh-syntax-highlight [3]</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<h3 id="4-Install-zsh-autosuggestions-4"><a href="#4-Install-zsh-autosuggestions-4" class="headerlink" title="#4 Install zsh-autosuggestions [4]"></a>#4 Install zsh-autosuggestions [4]</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<h3 id="5-Install-autojump-5"><a href="#5-Install-autojump-5" class="headerlink" title="#5 Install autojump [5]"></a>#5 Install autojump [5]</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/wting/autojump.git</span><br><span class="line">cd autojump</span><br><span class="line">./install.py</span><br></pre></td></tr></table></figure>

<h3 id="6-Edit-zshrc"><a href="#6-Edit-zshrc" class="headerlink" title="#6 Edit .zshrc"></a>#6 Edit .zshrc</h3><p>Change theme to “agnoster”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=&quot;agnoster&quot;</span><br></pre></td></tr></table></figure>

<p>Add default user to hide machine name and user name</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEFAULT_USER=&#x27;doot&#x27;</span><br></pre></td></tr></table></figure>

<p>make autojump available before source zsh.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[ -s /home/doot/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /home/doot/.autojump/etc/profile.d/autojump.sh</span><br></pre></td></tr></table></figure>

<p>add keybinding to accept autosuggestions, I use ‘,’ to accept suggestion</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zle -N autosuggest-accept</span><br><span class="line">bindkey &#x27;,&#x27; autosuggest-accept</span><br></pre></td></tr></table></figure>

<p>edit plguins, I enable wd docker etc. additionally.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plugins=(git web-search catimg wd zsh-syntax-highlighting zsh-autosuggestions docker zsh-completions cp docker-machine)</span><br></pre></td></tr></table></figure>

<h2 id="My-Terminal"><a href="#My-Terminal" class="headerlink" title="My Terminal"></a>My Terminal</h2><p>A simple video:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/n4cwU3dVprw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>Github, <a href="https://github.com/robbyrussell/oh-my-zsh">“robbyrussell&#x2F;oh-my-zsh”</a></li>
<li>Github, <a href="https://github.com/zsh-users/zsh-completions">“zsh-users&#x2F;zsh-completions”</a></li>
<li>Github, <a href="https://github.com/zsh-users/zsh-syntax-highlighting">“zsh-users&#x2F;zsh-syntax-highlighting”</a></li>
<li>Github, <a href="https://github.com/zsh-users/zsh-autosuggestions">“zsh-users&#x2F;zsh-autosuggestions”</a></li>
<li>Github, <a href="https://github.com/wting/autojump">“wting&#x2F;autojump”</a></li>
</ol>
]]></content>
      <tags>
        <tag>productivity</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>System Learning Daily 2</title>
    <url>/2019/06/20/System-Learning-Daily-2/</url>
    <content><![CDATA[<h2 id="X86-Calling-Convention"><a href="#X86-Calling-Convention" class="headerlink" title="X86 Calling Convention"></a>X86 Calling Convention</h2><p>上一篇Post最后有个疑问是，X86函数调用时，参数怎么传递，栈怎么管理。这些东西其实都是<code>Calling conventions</code>的内容[1]。</p>
<span id="more"></span>

<hr>
<h2 id="修改-terminal-xxx"><a href="#修改-terminal-xxx" class="headerlink" title="修改 _terminal_xxx"></a>修改 _terminal_xxx</h2><p>主要的大范围改动就是把函数调用时的参数传递由用栈来传递，改为直接使用寄存器来传递。</p>
<p>添加_terminal_putchar，支持屏幕的滚动。</p>
<p>修改_terminal_show，使用_terminal_putchar来显示字符。</p>
<p>具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.global _terminal_putchar</span><br><span class="line">.type _terminal_putchar STT_FUNC</span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief  put a char on screen</span></span><br><span class="line"><span class="comment">            it will read content in TER_ROW and TER_COL to get correct offset</span></span><br><span class="line"><span class="comment">    \param  al the char to put</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_terminal_putchar:</span><br><span class="line">    cmp al, <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    je tp_s1</span><br><span class="line"></span><br><span class="line"><span class="comment">// the char is not newline</span></span><br><span class="line">tp_s0:</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, [TER_ROW]</span><br><span class="line">    call _terminal_getoffset</span><br><span class="line">    shl ax</span><br><span class="line">    mov bx, ax</span><br><span class="line">    mov ax, VRAM</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov ah, DEFCOLOR</span><br><span class="line">    mov es:[bx], ax</span><br><span class="line">    cmp byte ptr [TER_COL], WIDTH - <span class="number">1</span></span><br><span class="line">    je tp_s1</span><br><span class="line">    inc byte ptr ds:[TER_COL]</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"><span class="comment">// the cursor should be at next line.</span></span><br><span class="line">tp_s1:</span><br><span class="line">    cmp byte ptr [TER_ROW], HEIGHT - <span class="number">1</span></span><br><span class="line">    jne tp_s2</span><br><span class="line"></span><br><span class="line"><span class="comment">// should scroll</span></span><br><span class="line">    push ds</span><br><span class="line">    call _terminal_scroll</span><br><span class="line">    pop ds</span><br><span class="line">    mov bl, HEIGHT - <span class="number">1</span></span><br><span class="line">    call _terminal_clearline <span class="comment">// clear line at bottom</span></span><br><span class="line">    sub byte ptr [TER_ROW], <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//should not scroll</span></span><br><span class="line">tp_s2:</span><br><span class="line">    inc byte ptr [TER_ROW]</span><br><span class="line">    mov byte ptr [TER_COL], <span class="number">0</span></span><br><span class="line">    mov ax, [TER_ROW]</span><br><span class="line">    call _terminal_getoffset</span><br><span class="line">    call _terminal_setcur</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.global _terminal_scroll</span><br><span class="line">.type _terminal_scroll STT_FUNC</span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    /brief  scroll the screen one line up</span></span><br><span class="line"><span class="comment">            it will not modify the TER_ROW and TER_COL</span></span><br><span class="line"><span class="comment">            it will not clear the line at bottom</span></span><br><span class="line"><span class="comment">            WARNING: it will change &quot;ds&quot; register</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_terminal_scroll:</span><br><span class="line">    mov cx, ( (HEIGHT - <span class="number">1</span>) * WIDTH) / <span class="number">2</span></span><br><span class="line">    mov ax, VRAM</span><br><span class="line">    cld</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov si, WIDTH * <span class="number">2</span></span><br><span class="line">    mov di, <span class="number">0</span></span><br><span class="line">    rep movsw</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h2 id="开始使用Makefile"><a href="#开始使用Makefile" class="headerlink" title="开始使用Makefile"></a>开始使用Makefile</h2><p>不用CMake的原因是，汇编源文件和C源文件混合编译不太好搞（我太菜了）。不如Make来得直接。在子文件夹里面Make生成bin文件，在根文件夹里面把bin文件合成，并且拷贝到build文件夹。细节就不写出来了，没什么技术水平。</p>
<h2 id="关于-“Call”-指令"><a href="#关于-“Call”-指令" class="headerlink" title="关于 “Call” 指令"></a>关于 “Call” 指令</h2><p>GUN AS, Intel Syntax</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br><span class="line">_buf1:</span><br><span class="line">.word <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">_buf2:</span><br><span class="line">.word <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">_buf3:</span><br><span class="line">.word <span class="number">0xCC</span></span><br><span class="line"></span><br><span class="line">.type _func STT_FUNC</span><br><span class="line">_func:</span><br><span class="line">    <span class="keyword">xor</span> ax, ax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    mov ax, _buf1</span><br><span class="line">    mov bx, _buf2</span><br><span class="line">    mov cx, _buf3</span><br></pre></td></tr></table></figure>

<p>此时，<code>ax</code>，<code>bx</code>，<code>cx</code>的值分别为：0x10，0x20，0xCC。这里，GAS <code>mov</code> 的是内存中的内容，然后</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mov ax, OFFSET _buf1</span><br><span class="line">mov bx, OFFSET _buf2</span><br><span class="line">mov cx, OFFSET _buf3</span><br></pre></td></tr></table></figure>

<p>此时，我们假定<code>.data</code>段从0x00开始，那么，<code>ax</code>，<code>bx</code>，<code>cx</code>的值会是0x00，0x02，0x04。也就是说，我们用<code>OFFSET</code>，可以得到<em>label</em>的地址。<strong>（此处存疑，OFFSET获得的是相对于段的偏移？还是获得绝对地址？似乎是获得绝对地址）</strong></p>
<p>现在让我们来考虑<code>call</code>指令的情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">call _func</span><br></pre></td></tr></table></figure>

<p>这显然是直接调用 _func，然后看下个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mov bx, OFFSET _func</span><br><span class="line">mov _buf1, bx</span><br><span class="line">call _buf1</span><br><span class="line">call [_buf1]</span><br></pre></td></tr></table></figure>

<p>现在 <code>_buf1</code> 中存储了 <code>_func</code> 的地址。现在有上面两种写法，第一种是错的，第二种写法是对的。第一种写法就是 <code>call label</code>，第二种写法才是我们想要的：“取出<code>_buf</code>中存储的地址，<code>jmp</code>到该地址。”。</p>
<p>这说明：在<code>mov</code>指令中和在<code>call</code>指令中出现的<em>label</em>会被GAS区别对待，他们有着不同的解释。</p>
<p>这个问题确实困扰了我好一会。</p>
<hr>
<h2 id="关于-“jmp-label”"><a href="#关于-“jmp-label”" class="headerlink" title="关于 “jmp label”"></a>关于 “jmp label”</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    jmp label</span><br><span class="line">    jmp <span class="type">short</span> label</span><br><span class="line">label:</span><br><span class="line">    hlt</span><br><span class="line">    jmp label</span><br></pre></td></tr></table></figure>

<p>这种直接<code>jmp label</code>的写法产生的机器码里面是没有绝对地址的，有的只是相对地址。把《汇编语言》[2]上面的一个例子拿过来(P.180 图9.3 转移位移的计算方法)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">偏移地址     机器码                   汇编指令</span><br><span class="line"><span class="number">0000</span>        <span class="number">40</span>                  s:  inc ax</span><br><span class="line"><span class="number">0001</span>        EB03                    jmp s0</span><br><span class="line"><span class="number">0003</span>        BB0300                  mov bx, <span class="number">3</span></span><br><span class="line"><span class="number">0006</span>        <span class="number">43</span>                  s0: inc bx</span><br><span class="line"><span class="number">0007</span>        EBF7                    jmp s</span><br><span class="line"><span class="number">0009</span>        <span class="number">90</span>                      nop</span><br></pre></td></tr></table></figure>

<p>这里0001偏移处的<code>jmp s0</code>指令生成的机器码是<code>EB03</code>，后面的<code>0x03</code>就是相对偏移地址。</p>
<p>为什么是<code>03</code>呢？<code>0006 - 0001 = 5</code>才对啊。其实8086处理器在将机器码放入缓冲区之后（还未执行改指令），就更新了<code>IP</code>寄存器的数值，所以在执行的时候<code>IP</code>的值已经是<code>0x03</code>了，所以编译器就把<code>0x03</code>放到了指令中。后面的<code>0xF7</code>是<code>-9</code>的补码，<code>0009 - 9 = 0000</code>，正好跳到了第一条指令。如果是有着多级流水线（Pipelining）的处理器，情况会变得更加复杂一些，在这里就不废话了（不瞎说了）[3]。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下以前的疑问：</p>
<ol>
<li><a href="/2019/06/18/System-Learning-Daily-1">System Learning Daily 1</a>， 疑问1的解答，就是该篇标题。</li>
</ol>
<p>新的疑问：</p>
<ol>
<li>不同的<code>call near, far</code>和<code>ret, retf</code>如何匹配。</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<ol>
<li>Wikipedia, <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">“x86 calling conventions”</a></li>
<li>王爽，《汇编语言》</li>
<li>NCCGROUP, <a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/september/arm-pipeline-and-gdb-oh-my/">“ARM, Pipeline and GDB, Oh My!”</a></li>
</ol>
</blockquote>
<h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h2><blockquote>
<p>2019-6-21<br>Add more content and publish the post.</p>
</blockquote>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title>System Learning Daily 1</title>
    <url>/2019/06/18/System-Learning-Daily-1/</url>
    <content><![CDATA[<h2 id="Boot-Sector"><a href="#Boot-Sector" class="headerlink" title="Boot Sector"></a>Boot Sector</h2><p>引导扇区是硬盘的第一个扇区，通常大小是512Byte，里面放着的是MBR(Master Boot Record)</p>
<blockquote>
<p>MBR 的主要内容</p>
<ol>
<li>一段8086实模式代码。</li>
<li>四个磁盘分区条目，每个条目是16Byte，紧挨着Magic Number。</li>
<li>在512Byte的末尾处（也就是在510Byte和511Byte的位置）有2个Byte作为Magic Number，分别是0x55、0xAA。</li>
</ol>
</blockquote>
<p>实际上现在的MBR有很多不同的标准，具体参考Wiki[1]。最简单也是最通用的就是上面这样的。</p>
<p>昨天主要写了一下16位实模式下面的引导程序代码。主要是把相关的字符模式下显卡的显示驱动给写好。至少能够在Qemu启动的时候，看到屏幕上面出现了<code>Hello World</code>。没有太多的了解磁盘分区条目。因为暂时没有用到，Magic Number怎么放入在上一篇文章里面已经贴出来LD脚本了，就不重复了。</p>
<p>Markdown似乎不支持汇编代码的高亮，看着白板总是觉得怪怪的，所以就随便用了C++的高亮。</p>
<p>具体代码如下：</p>
<hr>
<h2 id="相关汇编指令和常量定义"><a href="#相关汇编指令和常量定义" class="headerlink" title="相关汇编指令和常量定义"></a>相关汇编指令和常量定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.code16</span><br><span class="line"></span><br><span class="line">.set MAGIC1, <span class="number">0x55</span></span><br><span class="line">.set MAGIC2, <span class="number">0xAA</span></span><br><span class="line">.set DISRAM, <span class="number">0xB800</span></span><br><span class="line">.set FILLCHAR, <span class="string">&#x27; &#x27;</span></span><br><span class="line">.set DEFCOLOR, <span class="number">0x07</span></span><br><span class="line">.set HEIGHT, <span class="number">25</span></span><br><span class="line">.set WIDTH, <span class="number">80</span></span><br><span class="line">.set INITSEG, <span class="number">0x7C0</span></span><br><span class="line">.section .mbrcheck</span><br><span class="line">.byte MAGIC1</span><br><span class="line">.byte MAGIC2</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">_buffer:</span><br><span class="line">.skip <span class="number">0x20</span>, <span class="number">0x00</span></span><br><span class="line">.<span class="type">long</span> <span class="number">0xDEADBEFF</span></span><br><span class="line">_msg:</span><br><span class="line">.ascii <span class="string">&quot;Hello World\0&quot;</span></span><br><span class="line"></span><br><span class="line">.section .stack</span><br><span class="line">.skip <span class="number">0x20</span>, <span class="number">0x00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>.intel_syntax noprefix</code>是用来指定，下面的代码使用<code>Intel Syntax</code>，也有相关指令可以切换回<code>AT&amp;T Syntax</code>。[2]</p>
<p><code>.code16</code>是用来指定我们下面的代码是8086实模式的代码。</p>
<hr>
<h2 id="terminal-init"><a href="#terminal-init" class="headerlink" title="_terminal_init"></a>_terminal_init</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.global _terminal_init</span><br><span class="line">.type _terminal_init STT_FUNC</span><br><span class="line">_terminal_init:</span><br><span class="line">    mov ax, DISRAM</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ax, <span class="number">0</span></span><br><span class="line">    mov cx, HEIGHT</span><br><span class="line">ti_s0:</span><br><span class="line">    push cx</span><br><span class="line">    push ax</span><br><span class="line">    call _terminal_clearline</span><br><span class="line">    pop ax</span><br><span class="line">    pop cx</span><br><span class="line">    inc ax</span><br><span class="line">    loop ti_s0</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>写的是<code>init</code>，实际上这玩意是清除整个屏幕用的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">push cx</span><br><span class="line">push ax</span><br><span class="line">call _terminal_clearline</span><br><span class="line">pop ax</span><br><span class="line">pop cx</span><br></pre></td></tr></table></figure>

<p><code>push cx</code>是为了保存当前<code>cx</code>的数值，<code>push ax</code>是为了穿参数，ax指定了清除的行号（0开始）。<code>_terminal_clearline</code>写得有问题，传参数非得用栈不用寄存器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Style one */</span></span><br><span class="line">.type _terminal_init ,@function</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Style two */</span></span><br><span class="line">.type _terminal_init STT_FUNC</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里其实第一种和第二种的写法都可以，不过第二种更好一点，这一点在GAS的手册里面有讲到[3]。</p>
<hr>
<h2 id="terminal-clearline"><a href="#terminal-clearline" class="headerlink" title="_terminal_clearline"></a>_terminal_clearline</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.global _terminal_clearline</span><br><span class="line">.type _terminal_clearline STT_FUNC</span><br><span class="line">_terminal_clearline: <span class="comment">/*(u16 row)*/</span></span><br><span class="line">    mov bx, sp</span><br><span class="line">    mov bl, ss:[bx + <span class="number">2</span>]</span><br><span class="line">    mov al, WIDTH * <span class="number">2</span></span><br><span class="line">    mul bl</span><br><span class="line">    mov bx, ax</span><br><span class="line">    mov cx, WIDTH</span><br><span class="line">    mov al, FILLCHAR</span><br><span class="line">    mov ah, DEFCOLOR</span><br><span class="line">tcl_s0:</span><br><span class="line">    mov es:[bx], ax</span><br><span class="line">    add bx, <span class="number">2</span></span><br><span class="line">    loop tcl_s0</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>这个没啥好说的，接受紧挨着IP下面的16位数据作为行号，其实应该寄存器传参的。</p>
<hr>
<h2 id="terminal-setpos"><a href="#terminal-setpos" class="headerlink" title="_terminal_setpos"></a>_terminal_setpos</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.global _termianl_setpos</span><br><span class="line">.type _termianl_setpos STT_FUNC</span><br><span class="line">_termianl_setpos: <span class="comment">/*(u8 row, u8 column), return ax as pos*/</span></span><br><span class="line">    mov bx, sp</span><br><span class="line">    mov dh, <span class="number">0</span></span><br><span class="line">    mov dl, ss:[bx + <span class="number">3</span>]</span><br><span class="line">    add dl, dl</span><br><span class="line">    mov bl, ss:[bx + <span class="number">2</span>]</span><br><span class="line">    mov al, WIDTH * <span class="number">2</span></span><br><span class="line">    mul bl</span><br><span class="line">    add ax, dx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>这个函数是用来设置输出字符的位置的，返回的<code>ax</code>的值就是合适位置的显存地址，可以直接<code>mov bx, ax</code>然后顺序写入。栈里面的的16位数据，低八位是行，高八位数据是列。这个地方注释也有问题，没有说清楚具体的参数位置。</p>
<hr>
<h2 id="terminal-show"><a href="#terminal-show" class="headerlink" title="_terminal_show"></a>_terminal_show</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.global _terminal_show</span><br><span class="line">.type _terminal_show STT_FUNC</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    al is row</span></span><br><span class="line"><span class="comment">    ah is column</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_terminal_show: <span class="comment">/* (u8 *str, u8 row, u8 column) the pointer is 16Bit */</span></span><br><span class="line"></span><br><span class="line">    mov bx, sp</span><br><span class="line">    mov di, ss:[bx + <span class="number">2</span>]</span><br><span class="line">    mov ax, ss:[bx + <span class="number">4</span>]</span><br><span class="line">    push ax</span><br><span class="line">    call _termianl_setpos</span><br><span class="line">    pop dx</span><br><span class="line">    mov dx, ax</span><br><span class="line">    mov bx, <span class="number">0</span></span><br><span class="line">    mov ax, DISRAM</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ah, DEFCOLOR</span><br><span class="line">show_s0:</span><br><span class="line">    cmp byte ptr ds:[bx + di], <span class="number">0</span></span><br><span class="line">    je show_s1</span><br><span class="line">    mov al, ds:[bx + di]</span><br><span class="line">    mov si, bx</span><br><span class="line">    mov bp, bx</span><br><span class="line">    add bp, dx</span><br><span class="line">    mov es:[bp + si], ax</span><br><span class="line">    inc bx</span><br><span class="line">    jmp show_s0</span><br><span class="line">show_s1:</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>读取数据显示出来。存在的问题也还是注释也不对。参数怎么传递也是没讲清楚。</p>
<hr>
<h2 id="disk-read"><a href="#disk-read" class="headerlink" title="_disk_read"></a>_disk_read</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.global _disk_read</span><br><span class="line">.type _disk_read STT_FUNC</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ax , index of sector to read, only 7 bit work</span></span><br><span class="line"><span class="comment">    bx , buffer to store data</span></span><br><span class="line"><span class="comment">    cx , times of word(2-byte) to read</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">_disk_read:</span><br><span class="line"></span><br><span class="line">    push ax</span><br><span class="line">    mov al, <span class="number">1</span></span><br><span class="line">    mov dx, <span class="number">0x1F2</span></span><br><span class="line">    out dx, al</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    mov dx, <span class="number">0x1F3</span></span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    inc dx      <span class="comment">/*0x1F4*/</span></span><br><span class="line">    mov al, <span class="number">0x00</span></span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    inc dx      <span class="comment">/*0x1F5*/</span>  </span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    inc dx      <span class="comment">/*0x1F6*/</span></span><br><span class="line">    mov al, <span class="number">0xE0</span></span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    inc dx      <span class="comment">/*0x1F7*/</span></span><br><span class="line">    mov al, <span class="number">0x20</span></span><br><span class="line">    out dx, al</span><br><span class="line">dr_wait:</span><br><span class="line">    in al, dx</span><br><span class="line">    <span class="keyword">and</span> al, <span class="number">0x88</span></span><br><span class="line">    cmp al, <span class="number">0x08</span></span><br><span class="line">    jnz dr_wait</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*cx is buffer size*/</span></span><br><span class="line">    push cx</span><br><span class="line">    mov dx, <span class="number">0x1F0</span></span><br><span class="line"></span><br><span class="line">dr_read:</span><br><span class="line">    in ax, dx</span><br><span class="line">    mov ds:[bx], ax</span><br><span class="line">    add bx, <span class="number">2</span></span><br><span class="line">    loop dr_read</span><br><span class="line"></span><br><span class="line">    pop ax</span><br><span class="line">    mov cx, <span class="number">512</span></span><br><span class="line">    sub cx, ax</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    read the rest dummy data</span></span><br><span class="line"><span class="comment">    if we do not do so, next time when we read,</span></span><br><span class="line"><span class="comment">    the data would be the rest of last time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">dr_read_zero:</span><br><span class="line">    in ax, dx</span><br><span class="line">    loop dr_read_zero</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>这个是用来读磁盘的。写这个的时候就是全部采用寄存器传递参数了，参数怎么传递的也是相当的清楚。指定一提的是，每次读取数据的时候都要把整个扇区的数据全部读出来，不然没办法读别的数据，所以<code>dr_read_zero</code>就是空读，不写入到缓冲区里面。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下疑问在哪里</p>
<ol>
<li>如何进行x86下面的过程调用？调用过程的时候如何传递数据，栈里面的数据如何安排？</li>
<li>分区表条目具体是怎么样的？</li>
<li>真实的MBR代码都做了些什么？</li>
</ol>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<ol>
<li>Wikipedia, <a href="https://en.wikipedia.org/wiki/Master_boot_record">“Master boot record</a></li>
<li>Website of MIT, <a href="http://web.mit.edu/rhel-doc/3/rhel-as-en-3/i386-syntax.html">“AT&amp;T Syntax versus Intel Syntax”</a></li>
<li>GUN AS Manual, <a href="https://sourceware.org/binutils/docs/as/Type.html#Type">“7.98 .type”</a></li>
</ol>
</blockquote>
<hr>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><blockquote>
<p>2019-6-20<br>fix warnings in markdownlint.</p>
</blockquote>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title>System Learning Daily 3</title>
    <url>/2019/06/25/System-Learning-Daily-3/</url>
    <content><![CDATA[<h2 id="记一次工具的升级"><a href="#记一次工具的升级" class="headerlink" title="记一次工具的升级"></a>记一次工具的升级</h2><p>GDB 配合相关<em>gdbinit</em>脚本，加上内置的Python脚本支持。相当舒适。</p>
<span id="more"></span>

<blockquote>
<p>我用的是GEF[1]作为gdbinit</p>
</blockquote>
<p>上效果图:</p>
<p><img src="/img/gdb_gef_python.png" alt="效果图"></p>
<p>注意最下面<code>The target architecture is assumed to be i8086</code>，从这里开始后面的都是python脚本配置的</p>
<h2 id="GDB-内置支持-Python"><a href="#GDB-内置支持-Python" class="headerlink" title="GDB 内置支持 Python"></a>GDB 内置支持 Python</h2><blockquote>
<p>You can extend GDB using Python programming language.<br>From “Debugging with GDB” Tenth Edition</p>
</blockquote>
<p>写Bootloader的话，肯定要动态加载程序到内存的，这个调试就成了问题。</p>
<p>我是用的方案是使用<code>objcopy</code>来得到干净的调试符号文件之后，加载到gdb里面。</p>
<p>不过这就要对每个调试符号文件指定<code>.text</code>段的地址。</p>
<p>手动去查看，再手动的加入太烦了。于是就查了一下GDB的手册[2]。发现了可以使用Python来扩展。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> elftools.elf.elffile <span class="keyword">import</span> ELFFile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getSectionAddr</span>(<span class="params">filename, section_name</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        elffile = ELFFile(f)</span><br><span class="line">        dot_text = elffile.get_section_by_name(section_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dot_text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;WARNING: The section:\&quot;&#123;&#125;\&quot; dose not exists in file:\&quot;&#123;&#125;\&quot;.&#x27;</span>.<span class="built_in">format</span>(section_name, filename))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dot_text[<span class="string">&#x27;sh_addr&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myGDBAutoLoadSymFile</span>(<span class="params">filename</span>):</span><br><span class="line">    addr = getSectionAddr(filename, <span class="string">&#x27;.text&#x27;</span>)</span><br><span class="line">    gdb.execute(<span class="string">&#x27;add-symbol-file &#x27;</span> + filename + <span class="string">&#x27; &#x27;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    gdb.execute(<span class="string">&#x27;target remote localhost:1234&#x27;</span>)</span><br><span class="line">    gdb.execute(<span class="string">&#x27;set architecture i8086&#x27;</span>)</span><br><span class="line">    gdb.execute(<span class="string">&#x27;set disassembly-flavor intel&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    myGDBAutoLoadSymFile(<span class="string">&#x27;debug/boot.debug&#x27;</span>)</span><br><span class="line">    myGDBAutoLoadSymFile(<span class="string">&#x27;debug/loader.debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    gdb.execute(<span class="string">&#x27;b _start&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>使用pyelftools[3]来获取<code>.text</code>段的地址。直接自动加载。</p>
<h2 id="关于call和ret的匹配问题"><a href="#关于call和ret的匹配问题" class="headerlink" title="关于call和ret的匹配问题"></a>关于call和ret的匹配问题</h2><p>在loader里面把boot里面的函数都给封装一下，相当于可以间接远调用了。</p>
<p>封装是这样的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.global _wrap_ter_show</span><br><span class="line">.type _wrap_ter_show STT_FUNC</span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    /brief  wrapping the _terminal_show function call.</span></span><br><span class="line"><span class="comment">            return with retf</span></span><br><span class="line"><span class="comment">    /param  bx is buffer address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_wrap_ter_show:</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    mov ax, <span class="number">0</span></span><br><span class="line">    mov ds, ax</span><br><span class="line">    call [_terminal_show]</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line">    retf</span><br></pre></td></tr></table></figure>

<p>调用是这样的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mov bx, OFFSET _msg4</span><br><span class="line">push <span class="number">0x00</span></span><br><span class="line">push OFFSET _wrap_ter_show</span><br><span class="line">mov bp, sp</span><br><span class="line">call dword ptr ss:[bp]</span><br></pre></td></tr></table></figure>

<p>这样搞，也能把这些函数直接作为中断程序了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下以前的疑问：</p>
<ol>
<li><code>call</code>和<code>ret</code>的匹配问题，包装一下解决问题。</li>
</ol>
<p>新的疑问：</p>
<ol>
<li>在8086下搞重定位加载程序，总觉得好麻烦，不搞又觉得学的东西没价值，究竟搞不搞？</li>
</ol>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote>
<ol>
<li>Github, <a href="https://github.com/hugsy/gef">“hugsy&#x2F;gef”</a></li>
<li>Sourceware, <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">“Debugging with GDB”</a></li>
<li>Github, <a href="https://github.com/eliben/pyelftools/tree/master/elftools">“eliben&#x2F;pyelftools”</a></li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>system</tag>
        <tag>debug</tag>
        <tag>python</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>System Learning Daily 4</title>
    <url>/2020/05/02/System-Learning-Daily-4/</url>
    <content><![CDATA[<p>记录一些想法。</p>
<span id="more"></span>

<h2 id="关于QEMU和Bochs的选择"><a href="#关于QEMU和Bochs的选择" class="headerlink" title="关于QEMU和Bochs的选择"></a>关于QEMU和Bochs的选择</h2><ol>
<li>根据我自己的观察，使用Bochs的人似乎更多一些。我自己却是使用QEMU + GDB。</li>
<li>Bochs的优势在于调试这种裸机程序很好用。例如，在Bochs自带的调试器里面使用<code>info gdt</code>直接可以查看gdt，相较于QEMU + GDD更方便。</li>
<li>QEMU + GDB的好处就是可以借助GDB的强大功能，Bochs也可以使用GDB，但是必须关闭自带的调试器才行。而QEMU则可以两者同时使用。</li>
<li>两者的行为有些地方也不一致，例如QEMU默认的IF是set的，Bochs的IF是clear的。</li>
</ol>
<h2 id="无限循环引发GP"><a href="#无限循环引发GP" class="headerlink" title="无限循环引发GP"></a>无限循环引发GP</h2><p>GP就是<code>General Protection Exception</code>这个问题应该在我之前的项目中就出现过，不过我没有发现。这次发现主要是使用了QEMU的 <code>-d</code> 和 <code>-D</code> 选项，在处理器发生reset或者interrupt的时候打出log。</p>
<p>记录一下自己发现的过程。</p>
<ol>
<li>在实模式下面，<code>jmp $</code>不会引发GP</li>
<li>在保护模式下面，QEMU在运行到<code>jmp $</code>的时候直接重启Guest OS。</li>
<li>使用<code>-d int,cpu_reset</code> 和 <code>-D qemu.log</code>来查log发现是<code>triple fault</code>导致的重启。</li>
<li><code>triple fault</code>发生的原因是两次<code>GP</code>加上一个<code>double fault</code>，参考了这个帖子<a href="https://www.reddit.com/r/osdev/comments/67i6rf/using_qemu_on_a_regular_executable_runs_fine_but/">Reddit</a>。</li>
<li>让人疑惑的事情是，如果在gdb中使用<code>continue</code>则会出问题，如果使用<code>step</code>则不会出问题。<code>IF</code> set之后会出问题，<code>IF</code> clear之后不会出问题。在OSDev已经发帖问了。不清楚这究竟是处理器的机制还是我自己写的代码有问题。</li>
</ol>
<h2 id="CMake和Make的选择"><a href="#CMake和Make的选择" class="headerlink" title="CMake和Make的选择"></a>CMake和Make的选择</h2><p>写这种东西还是Make比较好用。CMake写起来是真的繁琐。还需要<code>add_custom_target</code>，语法噪音很多。不如Make直接一个target后面直接放上去命令来的简单明快。</p>
<h2 id="Linker-Script并不难"><a href="#Linker-Script并不难" class="headerlink" title="Linker Script并不难"></a>Linker Script并不难</h2><p>想不通几个月前的自己竟然浪费了不少时间在这个上面。</p>
<h2 id="内核要用ELF文件格式"><a href="#内核要用ELF文件格式" class="headerlink" title="内核要用ELF文件格式"></a>内核要用ELF文件格式</h2><p>之前使用的就是一个flat binary，刚开始还好，再往后就很容易出问题。非常不好管理。</p>
<h2 id="Just-for-Fun"><a href="#Just-for-Fun" class="headerlink" title="Just for Fun"></a>Just for Fun</h2><p>哪怕是对操作系统感兴趣，写起来遇到问题也是足够让人难受了。</p>
<p>得让自己开心。</p>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>system</tag>
        <tag>debug</tag>
        <tag>gdb</tag>
        <tag>qemu</tag>
        <tag>bochs</tag>
      </tags>
  </entry>
  <entry>
    <title>System Learning Daily 5</title>
    <url>/2020/05/03/System-Learning-Daily-5/</url>
    <content><![CDATA[<p>记一个大坑，坑里的问题十分诡异。</p>
<span id="more"></span>

<h2 id="ATA-PIO-Mode-的驱动问题"><a href="#ATA-PIO-Mode-的驱动问题" class="headerlink" title="ATA PIO Mode 的驱动问题"></a>ATA PIO Mode 的驱动问题</h2><p>这是个很简单的问题，稍加注意即可避免。但由于学艺不精，这个问题在九个月就困扰我，一直没有解决。</p>
<p>最近我终于发现了问题所在。</p>
<h3 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h3><p>这个问题会导致磁盘读写不全。</p>
<h3 id="遭遇的诡异问题"><a href="#遭遇的诡异问题" class="headerlink" title="遭遇的诡异问题"></a>遭遇的诡异问题</h3><p>MBR加载OSLoader的时候由于磁盘读写有问题，所以可能出现各种情况。我在此总结一下出现的各种奇怪的现象。</p>
<p>这些现象都很诡异。</p>
<ol>
<li>使用ATA PIO模式读硬盘时，传参数为N个<code>Sector</code>，实际上只能读出来N&#x2F;2个<code>Sector</code>。</li>
<li>在C语言代码中无法调用函数，如果调用函数则可能出现某个从实模式跳转到保护模式的jmp指令出错。出现这个问题的原因是:我把<code>GDT</code>放到了程序的最后面，本来<code>GDT</code>的位置是磁盘恰巧可以读出来的位置，然后，加入了一个函数调用，因为对齐的原因，<code>GDT</code>的位置跑到了硬盘恰巧读不出来的位置。在执行<code>jmp</code>的时候就会出现<code>GFP(Genaral Protection Fault)</code>，查看QEMU的log发现<code>error_code = 8</code>，正好是那个代码段的段选择子。</li>
<li>总之，由于磁盘读写不全，任何情况下，我只要修改了镜像的内存布局，程序的行为就会大变样。</li>
</ol>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>为什么会读写不全呢？</p>
<p>啊，感叹一句，还是怪我自己没有好好阅读 <a href="https://wiki.osdev.org/ATA_PIO_Mode">OSDev ATA_PIO_Mode</a> 上面的驱动代码实例，所以浪费了很多的时间。</p>
<p>每次在发送指令到<code>0x1f7</code>端口之后以及读完一个<code>Sector</code>之后，至少要等待400ns的时间，目的是获得准确的<code>Status Reister</code>的状态。等待400ns的最好方法就是直接插入四句如下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in al, dx</span><br></pre></td></tr></table></figure>

<p>每一次<code>in</code>都需要100ns的时间。具体细节请参考 <a href="https://wiki.osdev.org/ATA_PIO_Mode">OSDev ATA_PIO_Mode</a> </p>
<p>而我的读取硬盘的代码中这一部分内容缺失了，没有等待这400ns的时间。这就导致了这样一种奇怪的现象（也有可能不止于此，有可能更诡异）：</p>
<ol>
<li>Reading Sector_1 works</li>
<li>Reading Sector_2 doesn’t work</li>
<li>Reading Sector_3 works</li>
<li>Reading Sector_3 doesn’t work</li>
<li>…</li>
</ol>
<h3 id="我是怎么发现原因的"><a href="#我是怎么发现原因的" class="headerlink" title="我是怎么发现原因的"></a>我是怎么发现原因的</h3><p>很久以前我就发现了这样的一个问题，当时写了简单的MBR和一个仅仅实现了打log功能的Kernel(23333)。</p>
<p>那个时候我就发现磁盘读取不全，我的办法很奇怪，就是把读取数变大。当然，这样也会出现问题，不过问题没有那么严重了。</p>
<p>最近我再次对这个问题进行Debug，其实在这几天我学到了很多东西，使用工具也比以前更加地熟练。</p>
<p>最终，仔细阅读了 <a href="https://wiki.osdev.org/ATA_PIO_Mode">OSDev ATA_PIO_Mode</a> 上面的内容，才发现自己这里少了一些东西。</p>
<h2 id="Relief"><a href="#Relief" class="headerlink" title="Relief"></a>Relief</h2><p>从昨天晚上Debug到今天下午。其实没用多少时间。</p>
<p>问题解决了，很高兴~</p>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>system</tag>
        <tag>debug</tag>
        <tag>gdb</tag>
        <tag>qemu</tag>
        <tag>bochs</tag>
      </tags>
  </entry>
  <entry>
    <title>System Learning Daily 6</title>
    <url>/2020/05/04/System-Learning-Daily-6/</url>
    <content><![CDATA[<p>一个和GDT有关的Bug和相关Debug工具的使用。</p>
<span id="more"></span>

<h2 id="Segment-Descriptor中的B-x2F-D位"><a href="#Segment-Descriptor中的B-x2F-D位" class="headerlink" title="Segment Descriptor中的B&#x2F;D位"></a>Segment Descriptor中的B&#x2F;D位</h2><p>这是一个不小心导致的Bug。</p>
<p>在<code>Intel</code>的<code>Intel Architecture Software Developer&#39;s Manual, Volume 3</code>中写到:</p>
<blockquote>
<p>D&#x2F;B (default operation size&#x2F;default stack pointer size and&#x2F;or upper bound) flag  :<br>Performs different functions depending on whether the segment descriptor is an executable code segment, an expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and to 0 for 16-bit code and data segments.)</p>
</blockquote>
<p>进入保护模式之后，我们必然要使用32bit的代码段和数据段。但是我忘记将其置于1了。</p>
<p>于是就出现了一种奇怪的现象。</p>
<ol>
<li>IF flag set，程序在跳转到32bit代码段一瞬间就triple fault</li>
<li>IF flag clear，程序可以运行，跳转指令似乎还是可以运行的，但是有关数据的指令，无法修改数据。这就造成一种怪象。例如下面这段代码：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">osloader_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> counter3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        counter1 += counter2</span><br><span class="line">        counter2++;</span><br><span class="line">        <span class="keyword">if</span>(counter2 % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            counter3++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调试过程中，里面的这些<code>counter</code>变量都不会改变，一直仅仅保持一个数值。在调试器中，程序还是在一直运行着的。相当诡异了。</p>
<p>看下图。</p>
<p><img src="/img/System-Learning-Daily-6/1.png" alt="avator"></p>
<p>键入<code>si</code>，<code>print counter</code></p>
<p><img src="/img/System-Learning-Daily-6/2.png" alt="avator"></p>
<p><code>counter</code>的数值根本没变化，这很让人迷惑。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>我是用的虚拟机有两个，一个是<em>QEMU</em>，一个是<em>Bochs</em>。</p>
<p>具体优缺点我不太好分析，对我来说，<em>QEMU</em>我使用起来更加的熟悉。然而<em>Bochs</em>有个非常好的地方在于其自带的调试器，当然<em>Bochs</em>也可以使用GDB进行调试，不过自带的调试器和GDB只能选择一个。</p>
<p>列出来我自己的<em>QEMU</em>的启动参数吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -m 128M -hda build/img.bin -S \</span><br><span class="line">    -gdb tcp::1234 \            <span class="comment"># 设置GDB-Stub</span></span><br><span class="line">    -monitor stdio \            <span class="comment"># 设置*QEMU*的monitor窗口</span></span><br><span class="line">    -serial file:com1.log \     <span class="comment"># 设置串口输出的位置，可用来Debug</span></span><br><span class="line">    -d int,cpu_reset \          <span class="comment"># 设置，当产生中断，或者cpu reset的时候，写log</span></span><br><span class="line">    -D qemu.log                 <span class="comment"># 指定log的路径</span></span><br></pre></td></tr></table></figure>

<p><em>Bochs</em>的参数非常简单，就不在此列出了。</p>
<h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>显然，我用的是GDB了。值得一提的是，我是用了一个叫做GEF的GDB插件来优化GDB的使用体验。GEF非常适合这种可能要随时检查寄存器和栈的应用场景。</p>
<p>不得不说，GDB还是很强大的，使用Python脚本对其进行拓展更是让其异常强大。具体参考我之前的<a href="https://d0ot.github.io/2019/06/25/System-Learning-Daily-3/">System Learning Daily 3</a> </p>
<h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><p>就是GCC那一套了，汇编器使用nasm。</p>
<p>这种开发选择GCC总是没问题的。具体是根据<a href="https://wiki.osdev.org/Building_GCC">OSDev</a>上面的<em>Configure</em>构建的得到的。</p>
<h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><p>需要注意的就是使用一些编译选项了，我用的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CC_FLAGS = -std=gnu11 -ffreestanding -m32 -masm=intel -Wall -Wextra -Wno-address-of-packed-member -g -O0</span><br></pre></td></tr></table></figure>

<h4 id="ld"><a href="#ld" class="headerlink" title="ld"></a>ld</h4><p>有些地方确实需要会写链接脚本(Linker Script)，至少在<code>Kernel</code>的编译中，需要使用链接脚本。</p>
<h4 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h4><p>用来生成<code>flat binary</code>文件和Debug用的调试符号文件。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>主要是一些命令行工具。</p>
<h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>构建镜像的时候使用，直接通过dd来构建一个raw的文件，里面放入MBR，OSLoader，Kernel等。</p>
<p>截取makefile的一个小片段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=<span class="variable">$&#123;IMG_BIN&#125;</span> bs=1024 count=1024 conv=notrunc</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=boot/boot.bin of=<span class="variable">$&#123;IMG_BIN&#125;</span> bs=512 count=1 conv=notrunc seek=0</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=osloader/osloader.bin of=<span class="variable">$&#123;IMG_BIN&#125;</span> bs=512 conv=notrunc seek=</span><br></pre></td></tr></table></figure>

<h4 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h4><p>用来显示一个二进制文件，这是我发现读硬盘Bug的关键。配合diff使用，最终发现了硬盘读不全的问题。</p>
<h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxd dump.bin &gt; build/dump.bin.txt</span><br><span class="line">xxd build/img.bin &gt; build/img.bin.txt</span><br><span class="line">diff build/dump.bin.txt build/img.bin.txt -y | less</span><br></pre></td></tr></table></figure>

<p>当我们需要注意检查QEMU的内存中的内容是否与镜像一致时。</p>
<p>我们首先在QEMU的Monitor窗口中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memsave 0x7c00 0x2000 dump.bin</span><br></pre></td></tr></table></figure>
<p>保存从<em>0x7c00</em>开始的内存，长度为<em>0x2000</em>，到<code>dump.bin</code>文件中。</p>
<p>再看上面那个 <code>diff</code>的脚本，可以直接比较镜像内容与内存中的内容的差别。</p>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>system</tag>
        <tag>debug</tag>
        <tag>gdb</tag>
        <tag>qemu</tag>
        <tag>bochs</tag>
      </tags>
  </entry>
  <entry>
    <title>System Learning Daily 7</title>
    <url>/2020/07/15/System-Learning-Daily-7/</url>
    <content><![CDATA[<p>GCC 内联汇编的使用方法的自用记录。</p>
<span id="more"></span>

<h2 id="GCC-Extended-Asm"><a href="#GCC-Extended-Asm" class="headerlink" title="GCC Extended Asm"></a>GCC Extended Asm</h2><h3 id="asm-qualifiers"><a href="#asm-qualifiers" class="headerlink" title="asm-qualifiers"></a>asm-qualifiers</h3><p>有三个可选:</p>
<p>volatile，inline，goto.</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ol>
<li>代码有副作用(side effect)的时候使用。</li>
<li>如果汇编语句中没有Output内容，则默认 volatile。</li>
<li>如果没有volatile且汇编语句的Ouput内容没有被该语句下面的代码使用，则该汇编语句有可能被编译器优化掉。</li>
</ol>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>简单来说就是使得生成的汇编代码体积最小。</p>
<h4 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h4><p>没用过，似乎也没有用的理由，跳过。</p>
<h3 id="OutputOperand"><a href="#OutputOperand" class="headerlink" title="OutputOperand"></a>OutputOperand</h3><p>给例子，直接对比。</p>
<p>推荐借助<code>Compiler Explorer</code>来学习以下内容。</p>
<h4 id="example-1-“inc”"><a href="#example-1-“inc”" class="headerlink" title="example 1, “inc”"></a>example 1, “inc”</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inc1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;inc %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(a) : <span class="string">&quot;0&quot;</span>(a))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">inc2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;inc %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(a))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">inc3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;inc %0&quot;</span> : : <span class="string">&quot;r&quot;</span>(a))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">inc4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;inc %0&quot;</span> : <span class="string">&quot;+r&quot;</span>(a))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gcc 生成的无优化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inc1:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-4], 0</span><br><span class="line">        mov     eax, DWORD PTR [ebp-4]</span><br><span class="line">        inc eax</span><br><span class="line">        mov     DWORD PTR [ebp-4], eax</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">inc2:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-4], 0</span><br><span class="line">        inc eax</span><br><span class="line">        mov     DWORD PTR [ebp-4], eax</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">inc3:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-4], 0</span><br><span class="line">        mov     eax, DWORD PTR [ebp-4]</span><br><span class="line">        inc eax</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">inc4:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-4], 0</span><br><span class="line">        mov     eax, DWORD PTR [ebp-4]</span><br><span class="line">        inc eax</span><br><span class="line">        mov     DWORD PTR [ebp-4], eax</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<ol>
<li>inc1() 是正确写法。</li>
<li>inc2() 没有提前将 <code>a</code>写入<code>eax</code>。</li>
<li>inc3() 没有在<code>eax</code>自增之后回写到<code>a</code>。</li>
<li>inc4() 和 inc1() 有着相同的机器码，也是正确写法。不知道是不是完全相同的写法。</li>
</ol>
<h4 id="example-2-“bts”"><a href="#example-2-“bts”" class="headerlink" title="example 2, “bts”"></a>example 2, “bts”</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bts1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;bts %0, %1&quot;</span> : <span class="string">&quot;+r&quot;</span>(a) : <span class="string">&quot;r&quot;</span>(b) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bts2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;bts %0, %1&quot;</span> : <span class="string">&quot;=r&quot;</span>(a) : <span class="string">&quot;r&quot;</span>(b) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bts3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;bts %0, %1&quot;</span> : <span class="string">&quot;=r&quot;</span>(a) : <span class="string">&quot;0&quot;</span>(a) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bts4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;bts %0, %1&quot;</span> : <span class="string">&quot;+r&quot;</span>(a) : <span class="string">&quot;r&quot;</span>(a) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bts5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;bts %0, %1&quot;</span> : <span class="string">&quot;=r&quot;</span>(a) : <span class="string">&quot;0&quot;</span>(b) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>gcc 生成的无优化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bts1:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-4], 1</span><br><span class="line">        mov     DWORD PTR [ebp-8], 2</span><br><span class="line">        mov     edx, DWORD PTR [ebp-8]</span><br><span class="line">        mov     eax, DWORD PTR [ebp-4]</span><br><span class="line">        bts eax, edx</span><br><span class="line">        mov     DWORD PTR [ebp-4], eax</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">bts2:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-4], 1</span><br><span class="line">        mov     DWORD PTR [ebp-8], 2</span><br><span class="line">        mov     eax, DWORD PTR [ebp-8]</span><br><span class="line">        bts eax, eax</span><br><span class="line">        mov     DWORD PTR [ebp-4], eax</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">bts3:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-4], 1</span><br><span class="line">        mov     eax, DWORD PTR [ebp-4]</span><br><span class="line">        bts eax, eax</span><br><span class="line">        mov     DWORD PTR [ebp-4], eax</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">bts4:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-4], 1</span><br><span class="line">        mov     edx, DWORD PTR [ebp-4]</span><br><span class="line">        mov     eax, DWORD PTR [ebp-4]</span><br><span class="line">        bts eax, edx</span><br><span class="line">        mov     DWORD PTR [ebp-4], eax</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">bts5:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-4], 1</span><br><span class="line">        mov     DWORD PTR [ebp-8], 2</span><br><span class="line">        mov     eax, DWORD PTR [ebp-8]</span><br><span class="line">        bts eax, eax</span><br><span class="line">        mov     DWORD PTR [ebp-4], eax</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<ol>
<li>bts1() 是<code>bts a b</code>的正确写法。</li>
<li>bts2() 的<em>OutputOperands</em>前缀是<code>=</code>，则输入<code>a</code>与输出<code>b</code>都采用了同一个寄存器<code>eax</code>。</li>
<li>bts3() 在<em>InputOperands</em>中使用<em>Operands</em>标号可以将一个<em>InputOperand</em>和一个<em>OutputOperand</em>“连接(tie)”起来，使用同一个寄存器或者同一块内存地址。</li>
<li>bts4() 是<code>bts a a</code>的正确写法，可以吧<em>InputOperands</em>直接全部去掉。</li>
<li>bts5() 一个”连接(tie)“的例子，使用<code>eax</code>,输入<code>b</code>把结果放入<code>a</code>中。</li>
</ol>
<h4 id="example-3-multiple-assembler-instructions-1"><a href="#example-3-multiple-assembler-instructions-1" class="headerlink" title="example 3, multiple assembler instructions - 1"></a>example 3, multiple assembler instructions - 1</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multiple assembler instruction</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mai</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a = a + b + c, using ebx as strach register</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov ebx, 0\n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add ebx, %[a]\n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add ebx, %[b]\n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add ebx, %[c]\n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov %[a], ebx&quot;</span></span></span><br><span class="line"><span class="params">        : [a] <span class="string">&quot;+r&quot;</span>(a)</span></span><br><span class="line"><span class="params">        : [b] <span class="string">&quot;r&quot;</span>(b), [c] <span class="string">&quot;r&quot;</span>(c)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;ebx&quot;</span>, <span class="string">&quot;cc&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcc生成的无优化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mai:</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        push    ebx</span><br><span class="line">        sub     esp, 16</span><br><span class="line">        mov     DWORD PTR [ebp-8], 0</span><br><span class="line">        mov     DWORD PTR [ebp-12], 1</span><br><span class="line">        mov     DWORD PTR [ebp-16], 2</span><br><span class="line">        mov     edx, DWORD PTR [ebp-12]</span><br><span class="line">        mov     ecx, DWORD PTR [ebp-16]</span><br><span class="line">        mov     eax, DWORD PTR [ebp-8]</span><br><span class="line">        mov ebx, 0</span><br><span class="line">        add ebx, eax</span><br><span class="line">        add ebx, edx</span><br><span class="line">        add ebx, ecx</span><br><span class="line">        mov eax, ebx</span><br><span class="line">        mov     DWORD PTR [ebp-8], eax</span><br><span class="line">        nop</span><br><span class="line">        mov     ebx, DWORD PTR [ebp-4]</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>这个例子中，最下面的<code>ebx</code>告诉编译器，我们需要使用这个寄存器，所以编译器将该寄存器直接压栈保存，在<code>leave</code>中弹栈返回。</p>
<h4 id="example-4-multiple-assembler-instructions-2"><a href="#example-4-multiple-assembler-instructions-2" class="headerlink" title="example 4, multiple assembler instructions - 2"></a>example 4, multiple assembler instructions - 2</h4><blockquote>
<p>an example about <em>earlyclobber</em></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">baz1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;add %1, %0\n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add %1, %0&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;+r&quot;</span> (a) : <span class="string">&quot;r&quot;</span> (<span class="number">1</span>))</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">baz2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;add %1, %0\n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add %1, %0&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;+&amp;r&quot;</span> (a) : <span class="string">&quot;r&quot;</span> (<span class="number">1</span>))</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; gcc -m32 -O2 ...`</span><br><span class="line"></span><br><span class="line">baz1:</span><br><span class="line">        mov     eax, 1</span><br><span class="line">        add eax, eax</span><br><span class="line">        add eax, eax</span><br><span class="line">        ret</span><br><span class="line">baz2:</span><br><span class="line">        mov     edx, 1</span><br><span class="line">        mov     eax, edx</span><br><span class="line">        add edx, eax</span><br><span class="line">        add edx, eax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>对于 <code>baz1()</code>来说，编译器认为对 <code>1</code>的所有读都在写<code>a</code>之前，那么<code>1</code>和<code>a</code>自然可以使用同一个寄存器<code>eax</code>来存储数据，但这是不正确的，因为并不是读都在写之前。</p>
<p>对于 <code>baz2()</code>来说，我们使用了<code>&amp;</code>来告知编译器，所以编译器不会把一个寄存器既当做输入，又当做输出了。</p>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>asm</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/06/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>Start</tag>
      </tags>
  </entry>
  <entry>
    <title>Long Live My Blog !</title>
    <url>/2020/03/29/long-live-my-blog/</url>
    <content><![CDATA[<p>Just For Fun. XDDDDD</p>
<span id="more"></span>

<h1 id="Nothing-Here"><a href="#Nothing-Here" class="headerlink" title="Nothing Here"></a>Nothing Here</h1><p>I have just made my blog alive. The last update was 6 months aga and It is time to start again.</p>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>记录x86汇编的学习</title>
    <url>/2019/06/17/%E8%AE%B0%E5%BD%95x86%E6%B1%87%E7%BC%96%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="瞎写"><a href="#瞎写" class="headerlink" title="瞎写"></a>瞎写</h1><p>现在都快两点了,不怎么困…</p>
<p>今天也是摸鱼的一天…</p>
<p>其实还是有些收获的，至少怎么写链接脚本，怎么写MBR扇区的代码，还算是了解了一点点。(并没有学习x86汇编)</p>
<p>总结一下吧。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>东西很杂，就随便记录一下</strong></p>
<h3 id="i386-裸机环境搭建"><a href="#i386-裸机环境搭建" class="headerlink" title="i386 裸机环境搭建"></a>i386 裸机环境搭建</h3><pre><code>1. 编译 binutils

2. 编译 gcc
</code></pre>
<p>binutils 和 gcc 的源码可以去清华[1]或者科大的镜像站上面找，编译主要就是下面这几句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Varibale Settings</span></span><br><span class="line">export PREFIX=/usr/local/install_path</span><br><span class="line">export TARGET=i686-elf</span><br><span class="line">export PATH=&quot;$&#123;PREIFX&#125;/bin:$&#123;PATH&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">binutils configure</span></span><br><span class="line">binutils-xxx/configure --target=$TARGET --prefix=&quot;$PREFIX&quot; --with-sysroot --disable-werror</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc configure</span></span><br><span class="line">gcc-xxx/configure --target=$TARGET --prefix=&quot;$PREFIX&quot; --enable-languages=c,c++ --without-headers</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的内容是经过简化的，没把</p>
<blockquote>
<p>make<br>sudo make install</p>
</blockquote>
<p>写在里面，配置选项也很简单。</p>
<p>具体内容可以在 <em>OSDev Wiki</em> [2]上面找到，我就不写(抄)了。</p>
<h3 id="关于x86汇编的“方言”"><a href="#关于x86汇编的“方言”" class="headerlink" title="关于x86汇编的“方言”"></a>关于x86汇编的“方言”</h3><p>其实是两种语法(syntax)：</p>
<blockquote>
<p>AT&amp;A 和 Intel</p>
</blockquote>
<p>我是最近刚看的《汇编语言》第三版，上面讲的是 <em>Intel</em> 语法，而我打算用GAS来做汇编器，GAS默认使用 <em>AT&amp;T</em> 语法,这让我刚开始很困扰。不过后来我发现可以用一些编译指令[3]来使用 <em>Intel</em> 语法。这也不算个问题了。</p>
<h3 id="关于链接脚本"><a href="#关于链接脚本" class="headerlink" title="关于链接脚本"></a>关于链接脚本</h3><p>如何把MagicNumber放到最后面就是用的链接脚本。链接脚本指导连接器如何从对象文件里面获取所需要的内容，如何将这些内容在输出的文件中进行布局。具体参考官方手册[4]。</p>
<h3 id="MBR引导代码"><a href="#MBR引导代码" class="headerlink" title="MBR引导代码"></a>MBR引导代码</h3><p>大概半年前我才装上Ununtu真机。以前都是用虚拟机。装的时候搞出了点事情，发现我自己用的不是UEFI启动。用的还是Legacy BIOS。然后我就重新建立ESP分区，把Win10和Ubuntu的引导扔进去，加上GRUB。其实这里面的东西也能写一篇博客，因为遇到的问题还是挺多的。</p>
<p>MBR 是给 Legacy BIOS用的。存储设备的第一个扇区(Sector)的最后两个字节是<code>0x55</code>和<code>0xaa</code>，就会被BIOS当成一个可以启动的设备，BIOS将其512KiB加载到 0x0000:0x7c00 然后从这里开始运行。所以关键就是用链接脚本把 magic number 放到最后面，<code>.text</code> 放到最前面就好了。</p>
<p>给一个简单的小例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    /* BIOS will jump to here to run */</span><br><span class="line">    . = 0x00;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        *(.text)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allsize = ABSOLUTE(.);</span><br><span class="line">    .mbrcheck : </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        . = 512K - allsize - 2;</span><br><span class="line">        boot.o(.mbrcheck)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>链接的结果是生成ELF文件，用objcopy把没用的ELF头和符号表给去掉，生成Binary文件。这时候就可以尝试用Qemu来模拟了。</p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li>清华大学开源软件镜像站, “Index of &#x2F;gnu&#x2F;“, <a href="https://mirrors.tuna.tsinghua.edu.cn/gnu/">https://mirrors.tuna.tsinghua.edu.cn/gnu/</a></li>
<li>OSDev-Wiki, “GCC Cross-Compiler”, <a href="https://wiki.osdev.org/GCC_Cross-Compiler">https://wiki.osdev.org/GCC_Cross-Compiler</a></li>
<li>Stackoverflow, “Can I use Intel syntax of x86 assembly with GCC?”, <a href="https://stackoverflow.com/questions/9347909/can-i-use-intel-syntax-of-x86-assembly-with-gcc">https://stackoverflow.com/questions/9347909/can-i-use-intel-syntax-of-x86-assembly-with-gcc</a></li>
<li>Sourceware, “ld-docs”, <a href="https://sourceware.org/binutils/docs/ld/index.html">https://sourceware.org/binutils/docs/ld/index.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>x86</tag>
        <tag>system</tag>
      </tags>
  </entry>
</search>
